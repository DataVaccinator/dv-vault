= DataVaccinator Search Function
:author: DataVaccinator Team
:email: info@datavaccinator.com
:toc:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Foreword

The data vaccinator enables developers to easily implement pseudonymisation into their own projects. The drawback of many pseudonymisation solutions is the missing search functionality. It is not possible to search for pseudonymized data inside DataVaccinator Vault by default, because the payloads are encrypted and encrypted data can not get searched for. By this, the use-cases would be very limited to projects where this is not mandatory.

Many solutions need at least partial unencrypted data on the service storage to provide search functionality. There are several solutions in the market that work like this. We do not want to accept readable data inside of the DataVaccinator servers. Not even temporarily.
Thus, we looked for an option that prevents such drawbacks and avoids plain text information at all.

Another alternative we found is SSE (Searchable Symmetric Encryption). This concept was target for several dissertations and scientific research and mainly focusses on searching in whole documents (full-text search) and also represents cases for multi-user environments. So these concepts were not applicable for the DataVaccinator. At least, not for the moment.

The new DataVaccinator SearchHash algorithm offers a limited search functionality by using the local app-id (key) together with hashing functions. Sadly,  nothing comes without cost and a later chapter covers the security implications and, finally, every developer is free in his choice to use this feature or not.

== The SearchHash

The search functionality is gained by the SearchHash. A SearchHash is a function to create a special kind of hashcode for words that have to be searchable (searchwords, on other publications also called _term_, _token_ or _search token_).

The SearchHash for all words to be searchable has to become submitted together  with an _add_ or _update_ call to the DataVaccinator Vault. It will then provide search functionality that allows you searching for such SearchHashes, even partially if you always start from the left. The search function is available in DataVaccinator Vault by default.

The following describes, how to calculate the SearchHash for a given word (allways lowercase).

=== Calculation

The word to submit is processed letter by letter from left to right. For every letter in the loop from 1 to n, the following is applied:
****
h~n~ = Hash( _letter_ + h~n-1~ + _key_ )
****
While h~0~ is "f1748e9819664b324ae079a9ef22e33e9014ffce302561b9bf71a37916c1d2a3" and _letter_ is always the lowercase(!) representation of the letter to process. We also use the app-id as _key_.

During processing of the loop, the SearchHash is generated by concatenating the first 2 characters (first byte) of the generated hashcodes together.

=== Security option

In order to prevent attacks that are based on the length of the searchwords, the following must get applied for SearchHashes provided/pushed to dv-fault for storage:

If the length of the calculated SearchHash is not a multiple of 16, then continue calculation with a link:https://en.wikipedia.org/wiki/Null_character[Null character], followed by random characters. By this, the encrypted stored SearchWord (also IndexWord) can no longer become predicted by its length.

So, for the word `Sesame Street`, which is 13 bytes long (utf-8), we would process the word `Sesame StreetNRR` where N is a Null character and RR are two random bytes.

NOTE: Searching is not affected as the DataVaccinator Vault is always doing a _like_ search with a percent at the end. The NULL byte at the end ensures that the search does not hit random similar words because a byte with value 0 usually terminates strings (ascii or utf-8).

=== Example

Searchword=*FooBar*, used key=*1234* and used hash algorith is *SHA1*

NOTE: To keep it shorter in the examples, we only use SHA1 and init with "cbb10913b2445cc225b4fb81580a6d02e6ae3d42".
The real life implementation is working with SHA256 and initializes with "f1748e9819664b324ae079a9ef22e33e9014ffce302561b9bf71a37916c1d2a3".
****
h^1^ = SHA1("f" + "cbb10913b2445cc225b4fb81580a6d02e6ae3d42" + "1234") \=> **e3**5fd1a67cd6dc5f657c7d34b3290eadb08cd965
****
SearchHash = e3

****
h^2^ = SHA1("o" + "e35fd1a67cd6dc5f657c7d34b3290eadb08cd965" + "1234") \=> **8d**ae3523d0aa57fa9e0969644e114bd3ee89caa5
****
SearchHash = e38d

****
h^3^ = SHA1("o" + "8dae3523d0aa57fa9e0969644e114bd3ee89caa5" + "1234") \=> **b3**a6d6bbca1d2c704d39d409a742e5865f9f4d69
****
SearchHash = e38db3

****
h^4^ = SHA1("b" + "b3a6d6bbca1d2c704d39d409a742e5865f9f4d69" + "1234") \=> **c0**15ed50c3f6a5e02d09d9876b9f38381ffa1a42
****
SearchHash = e38db3c0

****
h^5^ = SHA1("a" + "c015ed50c3f6a5e02d09d9876b9f38381ffa1a42" + "1234") \=> **16**a5ce2a94266680f33403c18e6bdacd79468478
****
SearchHash = e38db3c016

****
h^6^ = SHA1("r" + "16a5ce2a94266680f33403c18e6bdacd79468478" + "1234") \=> **9c**b879120c6d91feb3ccac1876ca547745128747
****
SearchHash = e38db3c0169c

The above is a final and usable SearchHash. If the <<Security option>> is wanted for generation of the IndexWords (eg pushing data to dv-vault), we now continue with the Null character:

****
h^7^ = SHA1("\0" + "9cb879120c6d91feb3ccac1876ca547745128747" + "1234") \=> **27**8197ee57d0bd4f8ca55cde469d2eb61d931c4e
****
SearchHash = e38db3c0169c27

Now we continue that with 9 random characters. In our example we end up with

*SearchHash = e38db3c0169c27f7c3bc1d808e04732a*

This is a 32 character string because we always used the first two(!) characters of the 16 hashes we calculated.

== Searching

For searching, the same algorithm applies for the word to search but without the security option. First, you calculate the SearchHash for the text you like to search. For *foo*  it is *cb582b* (with above example values and hash algorithm). You simply provide this to the DataVaccinator Vault service and it  will do a _like_ query to the database of SearchHashes like *cb582b%*, returning all VIDs that contain searchwords starting with this specific sequence.

== Security Considerations

The representation of the SearchHashes is not without affecting security. The main goal of DataVaccinator is to protect the data from being assignable to people or leaking the payload.

* The *worst case* would be to retrieve the app-id (key) from that data. By this, the payloads may get decrypted and assignment to other data may become possible.
* *Another case* would be to assign the user FooBar to a PID inside the DataVaccinator database. But without the knowledge of the app-id (key) the rest of the PID data is still protected.

At first, we consider it very unlikely that someone is able to restore the app-id (key) from this information. This would mean to do a bruteforce attack on unknown data. We cannot rule out the possibility that there is still an attack vector that also makes it possible to unmask the key. This might become a topic for further research.

So let's have a look onto the data stored, assuming we only have data from one party in the database (all hashed/encrypted with the same app-id).

All users with a last name like "Footer", "Foomalin", "FooManChu" or "FooTiger" will have a SearchHash that starts with _e38db3_ (with above example values and hash algorithm). On a first look this sounds terrible. But in fact, someone who does not know the app-id, does only know that the three people share a last name with the same first three letters. But it is unknown what letters this are. It may be "Sch" like in Schmid or "Pro" like in Proske. So this is just a small indicator but no leak.

Someone may say that the risk of a statistical analysis and attack is likely on such data and we can not deny. There is the possibility that statistics may lead to some attack vector. By this, we mean the possibly that a set of payloads is then assigned to some word or name, in complete or partial. Like in "payload PID 88776633 is assigned to someone who's name is FooManChu". But please note that the payloads are still encrypted by the app-id. Without knowing that, we still consider the PID as secure.
